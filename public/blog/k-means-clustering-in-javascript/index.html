<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site  | K-Means Clustering in JavaScript</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.52" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="K-Means Clustering in JavaScript" />
<meta property="og:description" content="An example of the k-means algorithm in JavaScript." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/blog/k-means-clustering-in-javascript/" /><meta property="article:published_time" content="2015-02-25T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2015-02-25T00:00:00&#43;00:00"/>

<meta itemprop="name" content="K-Means Clustering in JavaScript">
<meta itemprop="description" content="An example of the k-means algorithm in JavaScript.">


<meta itemprop="datePublished" content="2015-02-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2015-02-25T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1982">



<meta itemprop="keywords" content="k-means,machine learning,data mining,algorithm,JavaScript,demo," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="K-Means Clustering in JavaScript"/>
<meta name="twitter:description" content="An example of the k-means algorithm in JavaScript."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://example.org/" class="f3 fw2 hover-white no-underline white-90 dib">
      My New Hugo Site
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        BLOGS
      </p>
      <h1 class="f1 athelas mb1">K-Means Clustering in JavaScript</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2015-02-25T00:00:00Z">February 25, 2015</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<p>Clustering is grouping of data or dividing a large data set into smaller data sets of some similarity. A well known clustering algorithm in unsupervised machine learning is <a href="http://en.wikipedia.org/wiki/K-means_clustering">K-Means clustering</a>. The K-Means algorithm takes in <code>n</code> observations (data points), and groups them into <code>k</code> clusters, where each observation belongs to a cluster based on the nearest mean (cluster centroid). The distance between a data point and cluster centroid is calculated using the <a href="http://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a>.</p>

<p><a href="http://en.wikipedia.org/wiki/Euclidean_distance"><img src="{{ .Site.BaseURL }}/euclidean-distance-model.png" alt="" /></a></p>

<h1 id="procedure">Procedure</h1>

<p>How the K-Means algorithm works is relatively straight forward. We just follow these steps:</p>

<ul>
<li>Step 1. Plot data points.</li>
<li>Step 2. Initialize <code>k</code> additional points which are the seeds (cluster centroids) by plotting them randomly on the graph within the boundaries of the <code>n</code> observation&rsquo;s dimenion ranges.</li>
<li>Step 3. Assign each <code>n</code> data point to it&rsquo;s closest cluster centroid (mean).</li>
<li>Step 4. Move the cluster centroid to the average position of all the data points that belong to that mean.</li>
<li>Step 5: Repeat steps 3 and 4 until there is no change in each cluster centroid movement. If means remain the same (nothing moved) then we know the algorithm has finished.</li>
</ul>

<p><code>K</code> is usually found by another algorithm to achieve the best k value, for example, by using the <a href="http://en.wikipedia.org/wiki/Bayesian_information_criterion">Bayesian information criterion</a>, <a href="http://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set#The_Elbow_Method">The Elbow Method</a>, or the <a href="http://en.wikipedia.org/wiki/Rule_of_thumb">Rule of thumb</a>, which is simply <code>k= √(n/2)</code>.</p>

<h1 id="algorithm">Algorithm</h1>

<p><a href="http://en.wikipedia.org/wiki/K-means_clustering"><img src="{{ .Site.BaseURL }}/k-means-clustering-model.png" alt="" /></a></p>

<blockquote>
<p>Given a set of observations <code>(x1, x2, …, xn)</code>, where each observation is a d-dimensional real vector, k-means clustering aims to partition the n observations into <code>k (≤ n)</code> sets <code>S = {S1, S2, …, Sk}</code> so as to minimize the within-cluster sum of squares (WCSS) where <code>μi</code> is the mean of points in <code>Si</code>. (<a href="http://en.wikipedia.org/wiki/K-means_clustering">wikipedia</a>)</p>
</blockquote>

<h3 id="credit">Credit</h3>

<p>Most of my understanding and knowledge of the K-Means algorithm and implementation came from <a href="http://burakkanber.com/blog/machine-learning-k-means-clustering-in-javascript-part-1/">this article</a> by <a href="https://twitter.com/bkanber">Burak Kanber</a>.</p>

<pre><code class="language-javascript">/**
* KMeans
* @constructor
* @desc KMeans constructor
* @param {object} options - options object
* @param {object} options.canvas - canvas element
* @param {array} options.data - data array with points
* @param {number} options.k - number of cluster centroids
* @return array with arrays of points
*/
function KMeans(opts) {
  // Create new instance if `new` keyword was not used.
  if (!(this instanceof KMeans)) {
    return new KMeans(opts);
  }

  opts = opts || {};
  this.canvas = opts.canvas;
  this.context = this.canvas.getContext('2d');
  this.width = this.canvas.width;
  this.height = this.canvas.height;

  // Number of cluster centroids.
  this.k = opts.k;

  // Points to cluster.
  this.data = opts.data;

  // Keeps track of which cluster centroid index each data point belongs to.
  this.assignments = [];

  // Get the extents (min,max) for the dimensions.
  this.extents = this.dataDimensionExtents();

  // Get the range of the dimensions.
  this.ranges = this.dataExtentRanges();

  // Generate random cluster centroid points.
  this.means = this.seeds();

  // Generate cluster colors.
  this.clusterColors = this.clusterColors();

  // Keep track of number of times centroids move.
  this.iterations = 0;

  // Clear the canvas.
  this.context.fillStyle = 'rgb(255,255,255)';
  this.context.fillRect(0, 0, this.width, this.height);

  // Draw the points onto canvas.
  this.draw();

  // Delay for each draw iteration.
  this.drawDelay = 20;

  // Perform work.
  this.run();
}

/**
* dataDimensionExtents
* @desc Returns the the minimum and maximum values for each dimention in the data array.
* @param {array} data - data containing points
* @return {array} extents - extents for each dimenion
* @example
* kmeans.data = [
*   [2,5],
*   [4,7],
*   [3,1]
* ];
* var extents = kmeans.dataDimensionExtents();
* console.log(extents); // [{min: 2, max: 4}, {min: 1, max: 7}]
*/
KMeans.prototype.dataDimensionExtents = function() {
  data = data || this.data;
  var extents = [];

  for (var i = 0; i &lt; data.length; i++) {
    var point = data[i];

    for (var j = 0; j &lt; point.length; j++) {
      if (!extents[j]) {
        extents[j] = {min: 1000, max: 0};
      }

      if (point[j] &lt; extents[j].min) {
        extents[j].min = point[j];
      }

      if (point[j] &gt; extents[j].max) {
        extents[j].max = point[j];
      }
    }
  }

  return extents;
};

/**
* dataExtentRanges
* @desc Returns the range for each extent
* @return {array} ranges
* kmeans.extents = [{min: 2, max: 4}, {min: 1, max: 7}]
* var ranges = kmeans.dataExtentRanges(extents);
* console.log(ranges); // [2,6]
*/
KMeans.prototype.dataExtentRanges = function() {
  var ranges = [];

  for (var i = 0; i &lt; this.extents.length; i++) {
    ranges[i] = this.extents[i].max - this.extents[i].min;
  }

  return ranges;
};

/**
* seeds
* @desc Returns an array of randomly generated cluster centroid points bounds based on the data dimension ranges.
* @return {array} cluster centroid points
* @example
* var means = kmeans.seeds();
* console.log(means); // [[2,3],[4,5],[5,2]]
*/
KMeans.prototype.seeds = function() {
  var means = [];
  while (this.k--) {
    var mean = [];

    for (var i = 0; i &lt; this.extents.length; i++) {
      mean[i] = this.extents[i].min + (Math.random() * this.ranges[i]);
    }

    means.push(mean);
  }

  return means;
};

/**
* assignClusterToDataPoints
* @desc Calculate Euclidean distance between each point and the cluster center.
* Assigns each point to closest mean point.
*
* The distance between two points is the length of the path connecting them.
* The distance between points P(p1,p2) and Q(q1,q2) is given by the Pythagorean theorem.
*
* distance = square root of ((p1 - q1)^2 + (p2 - q2)^2)
*
* For n dimensions, ie P(p1,p2,pn) and Q(q1,q2,qn).
* d(p,q) = square root of ((p1 - q1)^2 + (p2 - q2)^2 + ... + (pn - qn)^2)
*
* http://en.wikipedia.org/wiki/Euclidean_distance
*/
KMeans.prototype.assignClusterToDataPoints = function() {
  var assignments = [];

  for (var i = 0; i &lt; this.data.length; i++) {
    var point = this.data[i];
    var distances = [];

    for (var j = 0; j &lt; this.means.length; j++) {
      var mean = this.means[j];
      var sum = 0;

      /* We calculate the Euclidean distance.
       * √((pi-qi)^2+...+(pn-qn)^2)
       */

      for (var dim = 0; dim &lt; point.length; dim++) {
        // dif = (pn - qn)
        var difference = point[dim] - mean[dim];

        // dif = (dif)^2
        difference = Math.pow(difference, 2);

        // sum = (difi) + ... + (difn)
        sum += difference;
      }

      // √sum
      distances[j] = Math.sqrt(sum);
    }

    // After calculating all the distances from the data point to each cluster centroid,
    // we pick the closest (smallest) distances.
    assignments[i] = distances.indexOf(Math.min.apply(null, distances));
  }

  return assignments;
};


/**
 * moveMeans
 * @desc Update the positions of the the cluster centroids (means) to the average positions
 * of all data points that belong to that mean.
 */
KMeans.prototype.moveMeans = function() {
  var sums = fillArray(this.means.length, 0);
  var counts = fillArray(this.means.length, 0);
  var moved = false;
  var i;
  var meanIndex;
  var dim;

  // Clear location sums for each dimension.
  for (i = 0; i &lt; this.means.length; i++) {
    sums[i] = fillArray(this.means[i].length, 0);
  }

  // For each cluster, get sum of point coordinates in every dimension.
  for (var pointIndex = 0; pointIndex &lt; this.assignments.length; pointIndex++) {
    meanIndex = this.assignments[pointIndex];
    var point = this.data[pointIndex];
    var mean = this.means[meanIndex];

    counts[meanIndex]++;

    for (dim = 0; dim &lt; mean.length; dim++) {
      sums[meanIndex][dim] += point[dim];
    }
  }

  /* If cluster centroid (mean) is not longer assigned to any points,
   * move it somewhere else randomly within range of points.
   */
  for (meanIndex = 0; meanIndex &lt; sums.length; meanIndex++) {
    if (0 === counts[meanIndex]) {
      sums[meanIndex] = this.means[meanIndex];

      for (dim = 0; dim &lt; this.extents.length; dim++) {
        sums[meanIndex][dim] = this.extents[dim].min + (Math.random() * this.ranges[dim]);
      }
      continue;
    }

    for (dim = 0; dim &lt; sums[meanIndex].length; dim++) {
      sums[meanIndex][dim] /= counts[meanIndex];
      sums[meanIndex][dim] = Math.round(100*sums[meanIndex][dim])/100;
    }
  }

  /* If current means does not equal to new means, then
   * move cluster centroid closer to average point.
   */
  if (this.means.toString() !== sums.toString()) {
    var diff;
    moved = true;

    // Nudge means 1/nth of the way toward average point.
    for (meanIndex = 0; meanIndex &lt; sums.length; meanIndex++) {
      for (dim = 0; dim &lt; sums[meanIndex].length; dim++) {
        diff = (sums[meanIndex][dim] - this.means[meanIndex][dim]);
        if (Math.abs(diff) &gt; 0.1) {
          var stepsPerIteration = 10;
          this.means[meanIndex][dim] += diff / stepsPerIteration;
          this.means[meanIndex][dim] = Math.round(100*this.means[meanIndex][dim])/100;
        } else {
          this.means[meanIndex][dim] = sums[meanIndex][dim];
        }
      }
    }
  }

  return moved;
};

/**
 * run
 * @desc Reassigns nearest cluster centroids (means) to data points,
 * and checks if cluster centroids (means) have moved, otherwise
 * end program.
 */
KMeans.prototype.run = function() {
  ++this.iterations;

  // Reassign points to nearest cluster centroids.
  this.assignments = this.assignClusterToDataPoints();

  // Returns true if the cluster centroids have moved location since the last iteration.
  var meansMoved = this.moveMeans();

  /* If cluster centroids moved then
   *rerun to reassign points to new cluster centroid (means) positions.
   */
  if (meansMoved) {
    this.draw();
    this.timer = setTimeout(this.run.bind(this), this.drawDelay);
  } else {
    // Otherwise task has completed.
    console.log('Iteration took for completion: ' + this.iterations);
  }
};

KMeans.prototype.draw = function() {
  // Slightly clear the canvas to make new draws visible.
  this.context.fillStyle = 'rgba(255,255,255, 0.2)';
  this.context.fillRect(0, 0, this.width, this.height);

  var point;
  var i;

  /* Iterate though points draw line from their origin to their cluster centroid.
  * `assignments` contains cluster centroid index for each point.
  */
  for (i = 0; i &lt; this.assignments.length; i++) {
    var meanIndex = this.assignments[i];
    point = this.data[i];
    var mean = this.means[meanIndex];

    // Make lines that will get drawn alpha transparent.
    this.context.globalAlpha = 0.1;

    // Push current state onto the stack.
    this.context.save();

    this.context.beginPath();

    // Begin path from current point origin.
    this.context.moveTo(
      (point[0] - this.extents[0].min + 1) * (this.width / (this.ranges[0] + 2)),
      (point[1] - this.extents[1].min + 1) * (this.height / (this.ranges[1] + 2))
    );

    // Draw path from the point (moveTo) to the cluster centroid.
    this.context.lineTo(
      (mean[0] - this.extents[0].min + 1) * (this.width / (this.ranges[0] + 2)),
      (mean[1] - this.extents[1].min + 1) * (this.height / (this.ranges[1] + 2))
    );

    // Draw a stroke on the path to make it visible.
    this.context.strokeStyle = 'black';
    this.context.stroke();
    //this.context.closePath();

    // Restore saved state.
    this.context.restore();
  }

  // Plot every point onto canvas.
  for (i = 0; i &lt; data.length; i++) {
    this.context.save();

    point = this.data[i];

    // Make style fully opaque.
    this.context.globalAlpha = 1;

    // Move canvas origin on the grid to current point position.
    this.context.translate(
      (point[0] - this.extents[0].min + 1) * (this.width / (this.ranges[0] + 2)),
      (point[1] - this.extents[1].min + 1) * (this.width / (this.ranges[1] + 2))
    );

    this.context.beginPath();

    // Draw point circle.
    this.context.arc(0, 0, 5, 0, Math.PI*2, true);

    // Set the color for current point based on which cluster it belongs to.
    this.context.strokeStyle = this.clusterColor(this.assignments[i]);

    // Draw a stroke to make circle visible.
    this.context.stroke();
    this.context.closePath();

    this.context.restore();
  }

  // Draw cluster centroids (means).
  for (i = 0; i &lt; this.means.length; i++) {
    this.context.save();

    point = this.means[i];

    this.context.globalAlpha = 0.5;
    this.context.fillStyle = this.clusterColor(i);
    this.context.translate(
      (point[0] - this.extents[0].min + 1) * (this.width / (this.ranges[0] + 2)),
      (point[1] - this.extents[1].min + 1) * (this.width / (this.ranges[1] + 2))
    );
    this.context.beginPath();
    this.context.arc(0, 0, 5, 0, Math.PI*2, true);
    this.context.fill();
    this.context.closePath();

    this.context.restore();
  }
};

/**
* clusterColors
* @desc Generate a random colors for clusters.
* @return random colors
*/
KMeans.prototype.clusterColors = function() {
  var colors = [];

  // Generate point color for each cluster.
  for (var i = 0; i &lt; this.data.length; i++) {
    colors.push('#'+((Math.random()*(1&lt;&lt;24))|0).toString(16));
  }

  return colors;
};

/**
* clusterColor
* @desc Get color for cluster.
* @param {number} index - cluster (mean) index
* @return color for cluster
*/
KMeans.prototype.clusterColor = function(n) {
  return this.clusterColors[n];
};

/**
* fillArray
* @desc Returns a prefilled array.
* @param {number} length - length of array
* @param {*} value - value to prefill with.
* @return array with prefilled values.
*/
function fillArray(length, val) {
  return Array.apply(null, Array(length)).map(function() { return val; });
}
</code></pre>

<h1 id="usage">Usage</h1>

<p>Let&rsquo;s see it in action.</p>

<pre><code>var data = [
  [6,5],
  [9,10],
  [10,1],
  [5,5],
  [7,7],
  [4,1],
  [10,7],
  [6,8],
  [10,2],
  [9,4],
  [2,5],
  [9,1],
  [10,9],
  [2,8],
  [1,1],
  [6,10],
  [3,8],
  [2,3],
  [7,9],
  [7,7],
  [3,6],
  [5,8],
  [7,5],
  [10,9],
  [10,9]
];

var kmeans = new KMeans({
  canvas: document.getElementById('canvas'),
  data: data,
  k: 3
});
</code></pre>

<p><a href="{{ .Site.BaseURL }}/demo"><img src="{{ .Site.BaseURL }}/k-means-clustering-screenshot.png" alt="" /></a></p>

<p><a href="{{ .Site.BaseURL }}/demo">View the demo »</a></p>

<h1 id="conclusion">Conclusion</h1>

<p>As you can see in the demo, K-Means does a fairly good job in clustering data. If you run the algorithm thousands of times you can determine the best solution based on which solutions got returned the most often. Sometimes your dataset contains <a href="http://en.wikipedia.org/wiki/Outlier">outliers</a> and the <em>mean</em> may not be the best measure for clustering because the clusters may be heavily skewed, so in this scenario the <em><a href="http://en.wikipedia.org/wiki/K-medians_clustering">K-Medians</a></em> algorithm is your best bet.</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/k-means" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">k-means</a>
   </li>
  
   <li class="list">
     <a href="/tags/machine-learning" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">machine learning</a>
   </li>
  
   <li class="list">
     <a href="/tags/data-mining" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">data mining</a>
   </li>
  
   <li class="list">
     <a href="/tags/algorithm" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">algorithm</a>
   </li>
  
   <li class="list">
     <a href="/tags/javascript" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">JavaScript</a>
   </li>
  
   <li class="list">
     <a href="/tags/demo" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">demo</a>
   </li>
  
</ul>
<div class="mt6">
        
      </div>
    </section>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/blog/naive-bayes-classifier-in-javascript/">Naive Bayes Classifier in JavaScript</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/pixelate-images-with-canvas/">Pixelate images with Canvas</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/screenshots-with-getusermedia-api/">Screenshots with getUserMedia API</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/basic-html5-audio-manipulation/">Basic HTML5 Audio Manipulation</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/display-latest-delicious-bookmarks-with-jquery/">Display latest delicious bookmarks with jQuery</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/make-an-awesome-tooltip-with-jquery/">Make an Awesome Tooltip with jQuery</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/bytes/battery-status/">How to use Battery Status API</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/bytes/validate-domain-regex/">Regex to validate domain name</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/bytes/base64-mime-regex/">How to extract the MIME type from a base64 string.</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/es6-examples/">ES6 Examples</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/bytes/object-serialization/">How to serialize an object in JavaScript</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/getting-started-with-backbonejs/">Getting Started with Backbone.js</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/memoization-caching-function-results-in-javascript/">Memoization&amp;#58; Caching function results in JavaScript</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/slide-out-navigation-using-css3-translate/">Slide Out Navigation using CSS3 Translate</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/blog/call-and-apply-methods-in-javascript/">Call and Apply Methods in JavaScript</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy; 2019 My New Hugo Site
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
